import{_ as t,a as o}from"./arthas-output-svg.30f64f53.js";import{_ as r,o as l,c,a,b as n,e,d as i,r as d}from"./app.1e03d722.js";const p={},h=a("h1",{id:"profiler",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#profiler","aria-hidden":"true"},"#"),e(" profiler")],-1),u={href:"https://arthas.aliyun.com/doc/arthas-tutorials.html?language=en&id=command-profiler",target:"_blank",rel:"noopener noreferrer"},m=a("code",null,"profiler",-1),f=e(" online tutorial"),v={class:"custom-container tip"},b=a("p",{class:"custom-container-title"},"TIP",-1),g=e("Generate a flame graph using "),_={href:"https://github.com/jvm-profiling-tools/async-profiler",target:"_blank",rel:"noopener noreferrer"},y=e("async-profiler"),k=a("p",null,[e("The "),a("code",null,"profiler"),e(" command supports generating flame graph for application hotspots.")],-1),x=a("p",null,[e("The basic usage of the "),a("code",null,"profiler"),e(" command is "),a("code",null,"profiler action [actionArg]")],-1),w=e("The arguments of "),C=a("code",null,"profiler",-1),T=e(" command basically keeps consistent with upstream project "),j={href:"https://github.com/async-profiler/async-profiler",target:"_blank",rel:"noopener noreferrer"},S=e("async-profiler"),F=e(", you can refer to its README, Github Discussions and other documentations for further information of usage."),J=i(`<h2 id="supported-options" tabindex="-1"><a class="header-anchor" href="#supported-options" aria-hidden="true">#</a> Supported Options</h2><table><thead><tr><th style="text-align:right;">Name</th><th style="text-align:left;">Specification</th></tr></thead><tbody><tr><td style="text-align:right;"><em>action</em></td><td style="text-align:left;">Action to execute</td></tr><tr><td style="text-align:right;"><em>actionArg</em></td><td style="text-align:left;">Attribute name pattern</td></tr><tr><td style="text-align:right;">[i:]</td><td style="text-align:left;">sampling interval in ns (default: 10&#39;000&#39;000, i.e. 10 ms)</td></tr><tr><td style="text-align:right;">[f:]</td><td style="text-align:left;">dump output to specified directory</td></tr><tr><td style="text-align:right;">[d:]</td><td style="text-align:left;">run profiling for specified seconds</td></tr><tr><td style="text-align:right;">[e:]</td><td style="text-align:left;">which event to trace (cpu, alloc, lock, cache-misses etc.), default value is cpu</td></tr></tbody></table><h2 id="start-profiler" tabindex="-1"><a class="header-anchor" href="#start-profiler" aria-hidden="true">#</a> Start profiler</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ profiler start
Started [cpu] profiling
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>By default, the sample event is <code>cpu</code>. Other valid profiling modes can be specified with the <code>--event</code> parameter, see relevant contents below.</p></div><h2 id="get-the-number-of-samples-collected" tabindex="-1"><a class="header-anchor" href="#get-the-number-of-samples-collected" aria-hidden="true">#</a> Get the number of samples collected</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ profiler getSamples
23
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="view-profiling-status" tabindex="-1"><a class="header-anchor" href="#view-profiling-status" aria-hidden="true">#</a> View profiling status</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler status
<span class="token punctuation">[</span>cpu<span class="token punctuation">]</span> profiling is running <span class="token keyword">for</span> <span class="token number">4</span> seconds
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Can view which <code>event</code> and sampling time.</p><h2 id="view-profiler-memory-usage" tabindex="-1"><a class="header-anchor" href="#view-profiler-memory-usage" aria-hidden="true">#</a> View profiler memory usage</h2><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ profiler meminfo
Call trace storage:   10244 KB
      Dictionaries:      72 KB
        Code cache:   12890 KB
------------------------------
             Total:   23206 KB
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="stop-profiler" tabindex="-1"><a class="header-anchor" href="#stop-profiler" aria-hidden="true">#</a> Stop profiler</h2><h3 id="generating-flame-graph-results" tabindex="-1"><a class="header-anchor" href="#generating-flame-graph-results" aria-hidden="true">#</a> Generating flame graph results</h3>`,14),P=e("By default, the result file is "),I=a("code",null,"html",-1),G=e(" file in "),U={href:"https://github.com/BrendanGregg/FlameGraph",target:"_blank",rel:"noopener noreferrer"},N=e("Flame Graph"),O=e(" format. You can also specify other format with the "),R=a("code",null,"-o",-1),B=e(" or "),E=a("code",null,"--format",-1),M=e(" parameter, including flat, traces, collapsed, flamegraph, tree, jfr:"),W=i(`<div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler stop <span class="token parameter variable">--format</span> flamegraph
profiler output file: /tmp/test/arthas-output/20211207-111550.html
OK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>When extension of filename in <code>--file</code> parameter is <code>html</code> or <code>jfr</code>, the output format can be infered. For example, <code>--file /tmp/result.html</code> will generate flamegraph automatically.</p><h2 id="view-profiler-results-under-arthas-output-via-browser" tabindex="-1"><a class="header-anchor" href="#view-profiler-results-under-arthas-output-via-browser" aria-hidden="true">#</a> View profiler results under arthas-output via browser</h2>`,3),L=e("By default, arthas uses port 3658, which can be opened: "),V={href:"http://localhost:3658/arthas-output/",target:"_blank",rel:"noopener noreferrer"},A=e("http://localhost:3658/arthas-output/"),z=e(" View the "),$=a("code",null,"arthas-output",-1),D=e(" directory below Profiler results:"),Y=i('<p><img src="'+t+'" alt=""></p><p>Click to view specific results:</p><p><img src="'+o+`" alt=""></p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>If using the chrome browser, may need to be refreshed multiple times.</p></div><h2 id="profiler-supported-events" tabindex="-1"><a class="header-anchor" href="#profiler-supported-events" aria-hidden="true">#</a> Profiler supported events</h2><p>Under different platforms and different OSs, the supported events are different. For example, under macos:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler list
Basic events:
  cpu
  alloc
  lock
  wall
  itimer
  ctimer
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Under linux</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler list
Basic events:
  cpu
  alloc
  lock
  wall
  itimer
  ctimer
Java method calls:
  ClassName.methodName
Perf events:
  page-faults
  context-switches
  cycles
  instructions
  cache-references
  cache-misses
  branch-instructions
  branch-misses
  bus-cycles
  L1-dcache-load-misses
  LLC-load-misses
  dTLB-load-misses
  rNNN
  pmu/event-descriptor/
  mem:breakpoint
  trace:tracepoint
  kprobe:func
  uprobe:path
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,9),K=e("If you encounter the permissions/configuration issues of the OS itself and then missing some events, you can refer to the "),q={href:"https://github.com/jvm-profiling-tools/async-profiler",target:"_blank",rel:"noopener noreferrer"},H=e("async-profiler"),X=e(" documentation."),Q=i(`<p>You can use <code>check</code> action to check if a profiling event is available, this action receives the same format options with <code>start</code>.</p><p>You can use the <code>--event</code> parameter to specify the event to sample, for example, <code>alloc</code> event means heap memory allocation profiling:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler start <span class="token parameter variable">--event</span> alloc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="resume-sampling" tabindex="-1"><a class="header-anchor" href="#resume-sampling" aria-hidden="true">#</a> Resume sampling</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler resume
Started <span class="token punctuation">[</span>cpu<span class="token punctuation">]</span> profiling
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>The difference between <code>start</code> and <code>resume</code> is: <code>start</code> will clean existing result of last profiling before starting, <code>resume</code> will retain the existing result and add result of this time to it.</p><p>You can verify the number of samples by executing <code>profiler getSamples</code>.</p><h2 id="dump-action" tabindex="-1"><a class="header-anchor" href="#dump-action" aria-hidden="true">#</a> Dump action</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler dump
OK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>dump</code> action saves profiling result to default file or specified file, but profiling will continue. That means if you start profiling and dump after 5 seconds, then dump after 2 seconds again, you will get 2 result files, the first one contains profiling result of 0~5 seconds and the second one contains that of 0~7 seconds.</p><h2 id="use-execute-action-to-execute-complex-commands" tabindex="-1"><a class="header-anchor" href="#use-execute-action-to-execute-complex-commands" aria-hidden="true">#</a> Use <code>execute</code> action to execute complex commands</h2><p>For example, start sampling:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler execute <span class="token string">&#39;start,framebuf=5000000&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Stop sampling and save to the specified file:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler execute <span class="token string">&#39;stop,file=/tmp/result.html&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,15),Z=e("Specific format reference: "),ee={href:"https://github.com/async-profiler/async-profiler/blob/v2.9/src/arguments.cpp#L52",target:"_blank",rel:"noopener noreferrer"},ae=e("arguments.cpp"),se=i(`<h2 id="view-all-supported-actions" tabindex="-1"><a class="header-anchor" href="#view-all-supported-actions" aria-hidden="true">#</a> View all supported actions</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler actions
Supported Actions: <span class="token punctuation">[</span>resume, dumpCollapsed, getSamples, start, list, version, execute, meminfo, stop, load, dumpFlat, dump, actions, dumpTraces, status, check<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="view-version" tabindex="-1"><a class="header-anchor" href="#view-version" aria-hidden="true">#</a> View version</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>$ profiler version
Async-profiler <span class="token number">2.9</span> built on May  <span class="token number">8</span> <span class="token number">2023</span>
Copyright <span class="token number">2016</span>-2021 Andrei Pangin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="configure-java-stack-depth" tabindex="-1"><a class="header-anchor" href="#configure-java-stack-depth" aria-hidden="true">#</a> Configure Java stack depth</h2><p>You can use <code>-j</code> or <code>--jstackdepth</code> option to configure maximum Java stack depth. This option will be ignored if value is greater than default 2048. This option is useful when you don&#39;t want to see stacks that are too deep. Below is usage example:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-j</span> <span class="token number">256</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="profiling-different-threads-separately" tabindex="-1"><a class="header-anchor" href="#profiling-different-threads-separately" aria-hidden="true">#</a> Profiling different threads separately</h2><p>You can use <code>-t</code> or <code>--threads</code> flag option to profile different threads separately, each stack trace will end with a frame that denotes a single thread.</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-t</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="configure-include-exclude-to-filter-data" tabindex="-1"><a class="header-anchor" href="#configure-include-exclude-to-filter-data" aria-hidden="true">#</a> Configure include/exclude to filter data</h2><p>If the application is complex and generates a lot of content, and you want to focus on only part of stack traces, you can filter stack traces by <code>--include/--exclude</code>. <code>--include</code> defines the name pattern that must be present in the stack traces, while <code>--exclude</code> is the pattern that must not occur in any of stack traces in the output.A pattern may begin or end with a star <code>*</code> that denotes any (possibly empty) sequence of characters. such as</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler stop --include<span class="token string">&#39;java/*&#39;</span> <span class="token parameter variable">--include</span> <span class="token string">&#39;com/demo/*&#39;</span> --exclude<span class="token string">&#39;*Unsafe.park*&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>Both <code>--include/--exclude</code> support being set multiple times, but need to be configured at the end of the command line. You can also use short parameter format <code>-I/-X</code>. Note that <code>--include/--exclude</code> only supports configuration at <code>stop</code> action or <code>start</code> action with <code>-d</code>/<code>--duration</code> parameter, otherwise it will not take effect.</p></blockquote><h2 id="specify-execution-time" tabindex="-1"><a class="header-anchor" href="#specify-execution-time" aria-hidden="true">#</a> Specify execution time</h2><p>For example, if you want the profiler to automatically end after 300 seconds, you can specify it with the <code>-d</code>/<code>--duration</code> parameter in collect action:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler collect <span class="token parameter variable">--duration</span> <span class="token number">300</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="generate-jfr-format-result" tabindex="-1"><a class="header-anchor" href="#generate-jfr-format-result" aria-hidden="true">#</a> Generate jfr format result</h2><blockquote><p>Note that jfr only supports configuration at <code>start</code>. If it is specified at <code>stop</code>, it will not take effect.</p></blockquote><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>profiler start --file /tmp/test.jfr
profiler start -o jfr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>The <code>file</code> parameter supports some variables:</p><ul><li>Timestamp: <code>--file /tmp/test-%t.jfr</code></li><li>Process ID: <code>--file /tmp/test-%p.jfr</code></li></ul><p>The generated results can be viewed with tools that support the jfr format. such as:</p><ul><li>JDK Mission Control: https://github.com/openjdk/jmc</li><li>JProfiler: https://github.com/alibaba/arthas/issues/1416</li></ul><h2 id="control-details-in-result" tabindex="-1"><a class="header-anchor" href="#control-details-in-result" aria-hidden="true">#</a> Control details in result</h2>`,25),ne=e("The "),ie=a("code",null,"-s",-1),te=e(" parameter will use simple name instead of Fully qualified name, e.g. "),oe=a("code",null,"MathGame.main",-1),re=e(" instead of "),le=a("code",null,"demo.MathGame.main",-1),ce=e(". The "),de=a("code",null,"-g",-1),pe=e(" parameter will use method signatures instead of method names, e.g. "),he=a("code",null,"demo.MathGame.main([Ljava/lang/String;)V",-1),ue=e(" instead of "),me=a("code",null,"demo.MathGame.main",-1),fe=e(". There are many parameters related to result format details, you can refer to "),ve={href:"https://github.com/async-profiler/async-profiler#readme",target:"_blank",rel:"noopener noreferrer"},be=e("async-profiler README"),ge=e(" and "),_e={href:"https://github.com/async-profiler/async-profiler/discussions",target:"_blank",rel:"noopener noreferrer"},ye=e("async-profiler Github Discussions"),ke=e(" and other information."),xe=i(`<p>For example, in command below, <code>-s</code> use simple name for Java class, <code>-g</code> show method signatures, <code>-a</code> will annotate Java methods, <code>-l</code> will prepend library names for native method, <code>--title</code> specify a title for flame graph page, <code>--minwidth</code> will skip frames smaller than 15% in flame graph, <code>--reverse</code> will generate stack-reversed FlameGraph / Call tree.</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>profiler stop -s -g -a -l --title &lt;flametitle&gt; --minwidth 15 --reverse
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="the-unknown-in-profiler-result" tabindex="-1"><a class="header-anchor" href="#the-unknown-in-profiler-result" aria-hidden="true">#</a> The &#39;unknown&#39; in profiler result</h2><ul><li>https://github.com/jvm-profiling-tools/async-profiler/discussions/409</li></ul><h2 id="config-locks-allocations-profiling-threshold" tabindex="-1"><a class="header-anchor" href="#config-locks-allocations-profiling-threshold" aria-hidden="true">#</a> Config locks/allocations profiling threshold</h2><p>When profiling in locks or allocations event, you can use <code>--lock</code> or <code>--alloc</code> to config thresholds, for example:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-e</span> lock <span class="token parameter variable">--lock</span> 10ms
profiler start <span class="token parameter variable">-e</span> alloc <span class="token parameter variable">--alloc</span> 2m
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>will profile contended locks longer than 10ms (default unit is ns if no unit is specified), or profile allocations with 2m BYTES interval.</p><h2 id="config-jfr-chunks" tabindex="-1"><a class="header-anchor" href="#config-jfr-chunks" aria-hidden="true">#</a> Config JFR chunks</h2><p>When using JFR as output format, you can use <code>--chunksize</code> or <code>--chunktime</code> to config approximate size (in bytes, default value is 100MB) and time limits (default value is 1 hour) for a single JFR chunk. For example:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-f</span> profile.jfr <span class="token parameter variable">--chunksize</span> 100m <span class="token parameter variable">--chunktime</span> 1h
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="group-threads-by-scheduling-policy" tabindex="-1"><a class="header-anchor" href="#group-threads-by-scheduling-policy" aria-hidden="true">#</a> Group threads by scheduling policy</h2><p>You can use <code>--sched</code> flag option to group threads in output by Linux-specific scheduling policy: BATCH/IDLE/OTHER, for example:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">--sched</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>The second line from bottom in flamegraph represent the scheduling policy.</p><h2 id="build-allocation-profile-from-live-objects-only" tabindex="-1"><a class="header-anchor" href="#build-allocation-profile-from-live-objects-only" aria-hidden="true">#</a> Build allocation profile from live objects only</h2><p>Use <code>--live</code> flag option to retain allocation samples with live objects only (object that have not been collected by the end of profiling session). Useful for finding Java heap memory leaks.</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">--live</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="config-method-of-collecting-c-stack-frames" tabindex="-1"><a class="header-anchor" href="#config-method-of-collecting-c-stack-frames" aria-hidden="true">#</a> Config method of collecting C stack frames</h2><p>Use <code>--cstack MODE</code> to config how to walk native frames (C stack). Possible modes are fp (Frame Pointer), dwarf (DWARF unwind info), lbr (Last Branch Record, available on Haswell since Linux 4.1), and no (do not collect C stack).</p><p>By default, C stack is shown in cpu, itimer, wall-clock and perf-events profiles. Java-level events like alloc and lock collect only Java stack.</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler <span class="token parameter variable">--cstack</span> fp
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>The command above will collection Frame Pointer of C stacks.</p><h2 id="start-stop-profiling-when-a-specified-native-function-is-executed" tabindex="-1"><a class="header-anchor" href="#start-stop-profiling-when-a-specified-native-function-is-executed" aria-hidden="true">#</a> Start/Stop Profiling When a Specified Native Function is Executed</h2><p>Using the <code>--begin function</code> and <code>--end function</code> options, you can start or stop profiling when a specified native function is executed. The main use is to analyze specific JVM phases, such as GC and Safepoint. You need to use the native function names in the specific JVM implementation, such as SafepointSynchronize::begin and SafepointSynchronize::end in HotSpot JVM.</p><h3 id="time-to-safepoint-profiling" tabindex="-1"><a class="header-anchor" href="#time-to-safepoint-profiling" aria-hidden="true">#</a> Time-to-Safepoint Profiling</h3><p>The option <code>--ttsp</code> is actually an alias for <code>--begin SafepointSynchronize::begin --end RuntimeService::record_safepoint_synchronized</code>. It is a constraint, not a separate event type. The Profiler will work regardless of which event is selected, but only events between VM operations and Safepoint requests will be recorded.</p><p><code>profiler</code> now automatically includes profiler.Window events in the generated JFR file when the <code>--ttsp</code> option is used and a JFR output format is specified. These events represent the time interval of each Time-to-Safepoint pause, allowing you to analyze these pauses without relying on JVM logs.</p><p>Example</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">--begin</span> SafepointSynchronize::begin <span class="token parameter variable">--end</span> RuntimeService::record_safepoint_synchronized
profiler start <span class="token parameter variable">--ttsp</span> <span class="token parameter variable">--format</span> jfr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>The generated JFR file will contain profiler.Window events, which can be viewed and analyzed using tools such as JDK Mission Control.</p><p><strong>Notes:</strong></p><ul><li><p>profiler.Window events are generic events that apply to any time window using the --begin and --end triggers, not just Safepoint pauses.</p></li><li><p>When analyzing long Safepoint pauses, profiler.Window events can help you identify the cause of delays.</p></li><li><p>When using the --ttsp option, make sure to use the JFR output format so that profiler.Window events can be generated and viewed.</p></li></ul><h2 id="generate-jfr-file-using-events-recorded-by-profiler" tabindex="-1"><a class="header-anchor" href="#generate-jfr-file-using-events-recorded-by-profiler" aria-hidden="true">#</a> Generate JFR file using events recorded by profiler</h2><p>Use <code>--jfrsync CONFIG</code> option to specify configuration to start Java Flight Recording. The output jfr file will contain all normal JFR events, but the sampling sources are provided by the profiler.</p><p>CONFIG parameters:</p><ul><li><p>Preset configuration: CONFIG can be profile, which means to use the preset profile configuration in the $JAVA_HOME/lib/jfr directory.</p></li><li><p>Custom configuration file: CONFIG can also be a custom JFR configuration file (.jfc). The value of this option uses the same format as the settings option of the jcmd JFR.start command.</p></li><li><p>Specify a list of JFR events: Now, you can directly specify the list of JFR events to be enabled in --jfrsync without creating a .jfc file. To specify a list of events, start with + and separate multiple events with +.</p></li></ul><p>Example:</p><p>Start JFR with a preset profile configuration:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-e</span> cpu <span class="token parameter variable">--jfrsync</span> profile <span class="token parameter variable">-f</span> combined.jfr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Directly specify a list of JFR events, for example, to enable jdk.YoungGarbageCollection and jdk.OldGarbageCollection events:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-e</span> cpu <span class="token parameter variable">--jfrsync</span> +jdk.YoungGarbageCollection+jdk.OldGarbageCollection <span class="token parameter variable">-f</span> combined.jfr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Notes</strong></p><ul><li>When specifying a list of events, events are separated by a plus sign + because commas , are used to separate different options.</li><li>If the --jfrsync parameter does not start with +, it is treated as a preset profile name or a path to a .jfc configuration file.</li><li>Directly specifying a list of events is particularly useful when the target application is running in a container, without additional file operations.</li></ul><h2 id="run-profiler-in-a-loop" tabindex="-1"><a class="header-anchor" href="#run-profiler-in-a-loop" aria-hidden="true">#</a> Run profiler in a loop</h2><p>Use <code>--loop TIME</code> to run profiler in a loop (continuous profiling). The argument is either a clock time (hh:mm:ss) or a loop duration in seconds, minutes, hours, or days. Make sure the filename includes a timestamp pattern, or the output will be overwritten on each iteration. The command below will run profiling endlessly and save records of each hour to a jfr file.</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">--loop</span> 1h <span class="token parameter variable">-f</span> /var/log/profile-%t.jfr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="timeout-option" tabindex="-1"><a class="header-anchor" href="#timeout-option" aria-hidden="true">#</a> <code>--timeout</code> option</h2><p>This option specifies the time when profiling will automatically stop. The format is the same as in loop: it is either a wall clock time (12:34:56) or a relative time interval (2h).</p>`,49),we=e("Both "),Ce=a("code",null,"--loop",-1),Te=e(" and "),je=a("code",null,"--timeout",-1),Se=e(" are used for "),Fe=a("code",null,"start",-1),Je=e(" action but not for "),Pe=a("code",null,"collect",-1),Ie=e(" action, for further information refer to "),Ge={href:"https://github.com/async-profiler/async-profiler/discussions/789",target:"_blank",rel:"noopener noreferrer"},Ue=e("async-profiler Github Discussions"),Ne=e("."),Oe=i(`<h2 id="wall-option" tabindex="-1"><a class="header-anchor" href="#wall-option" aria-hidden="true">#</a> <code>--wall</code> option</h2><p>The -- wall option allows for simultaneous performance analysis of both CPU and Wall Clock. This joint analysis helps to more comprehensively identify and understand performance bottlenecks in applications. --The wall option allows users to set the sampling interval for Wall Clock analysis independently of CPU analysis. For example, by setting - e cpu-i 10-- wall 200, the CPU sampling interval can be set to 10 milliseconds, and the wall clock sampling interval can be set to 200 milliseconds. When conducting joint CPU and Wall Clock analysis, the output format must be set to jfr. This format supports recording the state information of threads (such as State_SUNNABLE or State_SLEEPING) to distinguish between different types of sampling events.</p><p>influence Linux platform: This new feature is only available on the Linux platform. The CPU analysis engine on macOS is already based on Wall clock mode, so there are no additional benefits. Performance overhead: Enabling Wall clock analysis will increase performance overhead, so when analyzing both CPU and Wall clock simultaneously, it is recommended to increase the interval between Wall clocks.</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-e</span> cpu <span class="token parameter variable">-i</span> <span class="token number">10</span> <span class="token parameter variable">--wall</span> <span class="token number">100</span> <span class="token parameter variable">-f</span> out.jfr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="ctimer-events" tabindex="-1"><a class="header-anchor" href="#ctimer-events" aria-hidden="true">#</a> <code>ctimer</code> events</h2><p><code>ctimer</code> events are a new CPU sampling mode based on <code>timer_create</code>, providing accurate CPU sampling without <code>perf_events</code>.</p><p>In some cases, <code>perf_events</code> may not be available, for example due to <code>perf_event_paranoid</code> settings or <code>seccomp</code> restrictions, or in container environments. Although itimer events can work in containers, there may be sampling inaccuracies.</p><p><code>ctimer</code> events combine the advantages of <code>cpu</code> and <code>itimer</code>:</p><ul><li><p>High accuracy: provides accurate CPU sampling.</p></li><li><p>Container-friendly: available in containers by default.</p></li><li><p>Low resource consumption: does not consume file descriptors.</p></li></ul>`,9),Re=e("**Note that "),Be=a("code",null,"ctimer",-1),Ee=e(" events are currently only supported on "),Me=a("code",null,"Linux",-1),We=e(", not "),Le=a("code",null,"macOS",-1),Ve=e(". ** See "),Ae={href:"https://github.com/async-profiler/async-profiler/issues/855",target:"_blank",rel:"noopener noreferrer"},ze=e("async-profiler Github Issues"),$e=e(" for more information."),De=i(`<p>Example:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-e</span> ctimer <span class="token parameter variable">-o</span> jfr <span class="token parameter variable">-f</span> ./out-test.jfr
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="vtable-feature" tabindex="-1"><a class="header-anchor" href="#vtable-feature" aria-hidden="true">#</a> <code>vtable</code> Feature</h2><p>In some applications, a lot of CPU time is spent in calling <code>megamorphic</code> virtual or interface methods, which is shown as <code>vtable stub</code> or <code>itable stub</code> in performance analysis. This does not help us understand why a specific call site is <code>megamorphic</code> and how to optimize it.</p><p>The vtable feature can add a pseudo frame on top of the <code>vtable stub</code> or <code>itable stub</code>, showing the actual object type being called. This helps to clearly understand the ratio of different receivers at a specific call site.</p>`,5),Ye=e("This feature is disabled by default and can be enabled with the "),Ke=a("code",null,"-F vtable",-1),qe=e(" option (or using "),He=a("code",null,"features=vtable",-1),Xe=e("). See the "),Qe={href:"https://github.com/async-profiler/async-profiler/issues/736",target:"_blank",rel:"noopener noreferrer"},Ze=e("async-profiler Github Issues"),ea=e(" for more information."),aa=i(`<p>Example:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-F</span> vtable
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="comptask-feature" tabindex="-1"><a class="header-anchor" href="#comptask-feature" aria-hidden="true">#</a> <code>comptask</code> feature</h2><p><code>profiler</code> samples the JIT compiler threads as well as the Java threads, and can show the percentage of CPU consumed by JIT compilation. However, the compilation resource consumption of Java methods varies, and it is useful to know which specific Java methods consume the most CPU time when compiling.</p><p>The <code>comptask</code> feature adds a virtual frame to the stack trace of <code>C1/C2</code>, showing the current task being compiled, that is, the Java method being compiled.</p>`,5),sa=e("This feature is disabled by default and can be enabled with the "),na=a("code",null,"-F comptask",-1),ia=e(" option (or using "),ta=a("code",null,"features=comptask",-1),oa=e("). See "),ra={href:"https://github.com/async-profiler/async-profiler/issues/777",target:"_blank",rel:"noopener noreferrer"},la=e("async-profiler Github Issues"),ca=e(" for more information."),da=i(`<p>Example:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">-F</span> comptask
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="configuring-alternative-profiling-signals" tabindex="-1"><a class="header-anchor" href="#configuring-alternative-profiling-signals" aria-hidden="true">#</a> Configuring Alternative Profiling Signals</h2><p><code>profiler</code> uses <code>POSIX</code> signals for performance profiling. By default, <code>SIGPROF</code> is used for <code>CPU</code> profiling and <code>SIGVTALRM</code> is used for <code>Wall-Clock</code> profiling. However, this can lead to signal conflicts if your application also uses these signals or if you want to run multiple <code>profiler</code> instances simultaneously.</p><p>You can now use the <code>signal</code> parameter to configure the signal used for profiling to avoid conflicts.</p>`,5),pa=e("See "),ha={href:"https://github.com/async-profiler/async-profiler/issues/759",target:"_blank",rel:"noopener noreferrer"},ua=e("async-profiler Github Issues"),ma=e(" for more information."),fa=i(`<p>Syntax</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">--signal</span> <span class="token operator">&lt;</span>signal number<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>If you need to specify the signal for CPU and Wall-Clock analysis separately, you can use the following syntax:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">--signal</span> <span class="token operator">&lt;</span>CPU signal number<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>Wall signal number<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="clock-option" tabindex="-1"><a class="header-anchor" href="#clock-option" aria-hidden="true">#</a> <code>--clock</code> option</h2><p>The <code>--clock</code> option allows the user to control the clock source used for sampling timestamps. This is useful for scenarios where you need to align the timestamps of <code>profiler</code> data with data from other tools.</p><p>Usage</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">--clock</span> <span class="token operator">&lt;</span>tsc<span class="token operator">|</span>monotonic<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Parameters</p>`,9),va=a("li",null,[a("p",null,[a("code",null,"tsc"),e(": Use the CPU's timestamp counter ("),a("code",null,"RDTSC"),e("). This is the default option and provides high-precision timestamps.")])],-1),ba=a("code",null,"monotonic",-1),ga=e(": Use the operating system's monotonic clock ("),_a=a("code",null,"CLOCK_MONOTONIC",-1),ya=e("). This helps align timestamps between multiple data sources. See "),ka={href:"https://github.com/async-profiler/async-profiler/issues/723",target:"_blank",rel:"noopener noreferrer"},xa=e("async-profiler Github Issues"),wa=e(" for more information."),Ca=i(`<p>Example:</p><p>Using <code>CLOCK_MONOTONIC</code> as timestamp source:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">--clock</span> monotonic
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Notes:</strong></p><ul><li><p>Use <code>--clock monotonic</code> when you need to align <code>profiler</code> data with data from other tools that use <code>CLOCK_MONOTONIC</code> (e.g. <code>perf</code>).</p></li><li><p>Use <code>--clock</code> option with caution when using <code>jfrsync</code> mode, as the JVM and <code>profiler</code> may use different timestamp sources, which may lead to inconsistent results.</p></li></ul><h2 id="norm-option" tabindex="-1"><a class="header-anchor" href="#norm-option" aria-hidden="true">#</a> <code>--norm</code> option</h2><p>In Java 20 and earlier, the method names generated by the compiler for <code>lambda</code> expressions contain a unique numeric suffix. For example, a <code>lambda</code> expression defined in the same code location may generate multiple different frame names, because each <code>lambda</code> method name is appended with a unique numeric suffix (such as <code>lambda$method$0</code>, <code>lambda$method$1</code>, etc.). This causes logically identical stacks to not be merged in the flame graph, increasing the complexity of performance analysis.</p>`,7),Ta=e("To solve this problem, "),ja=a("code",null,"profiler",-1),Sa=e(" has added a "),Fa=a("code",null,"--norm",-1),Ja=e(" option that automatically normalizes method names when generating output, removes these numeric suffixes, and enables identical stacks to be merged correctly. Please refer to "),Pa={href:"https://github.com/async-profiler/async-profiler/issues/832",target:"_blank",rel:"noopener noreferrer"},Ia=e("async-profiler Github Issues"),Ga=e(" for more information."),Ua=i(`<p><strong>Example:</strong></p><p>Generate a normalized flame graph:</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>profiler start <span class="token parameter variable">--norm</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,3);function Na(Oa,Ra){const s=d("ExternalLinkIcon");return l(),c("div",null,[h,a("p",null,[a("a",u,[m,f,n(s)])]),a("div",v,[b,a("p",null,[g,a("a",_,[y,n(s)])])]),k,x,a("p",null,[w,C,T,a("a",j,[S,n(s)]),F]),J,a("p",null,[P,I,G,a("a",U,[N,n(s)]),O,R,B,E,M]),W,a("p",null,[L,a("a",V,[A,n(s)]),z,$,D]),Y,a("p",null,[K,a("a",q,[H,n(s)]),X]),Q,a("p",null,[Z,a("a",ee,[ae,n(s)])]),se,a("p",null,[ne,ie,te,oe,re,le,ce,de,pe,he,ue,me,fe,a("a",ve,[be,n(s)]),ge,a("a",_e,[ye,n(s)]),ke]),xe,a("p",null,[we,Ce,Te,je,Se,Fe,Je,Pe,Ie,a("a",Ge,[Ue,n(s)]),Ne]),Oe,a("p",null,[Re,Be,Ee,Me,We,Le,Ve,a("a",Ae,[ze,n(s)]),$e]),De,a("p",null,[Ye,Ke,qe,He,Xe,a("a",Qe,[Ze,n(s)]),ea]),aa,a("p",null,[sa,na,ia,ta,oa,a("a",ra,[la,n(s)]),ca]),da,a("p",null,[pa,a("a",ha,[ua,n(s)]),ma]),fa,a("ul",null,[va,a("li",null,[a("p",null,[ba,ga,_a,ya,a("a",ka,[xa,n(s)]),wa])])]),Ca,a("p",null,[Ta,ja,Sa,Fa,Ja,a("a",Pa,[Ia,n(s)]),Ga]),Ua])}const Ma=r(p,[["render",Na],["__file","profiler.html.vue"]]);export{Ma as default};
